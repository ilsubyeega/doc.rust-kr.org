<!DOCTYPE HTML>
<html lang="ko" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>벡터에 여러 값의 목록 저장하기 - Rust 프로그래밍 언어</title>


        <!-- Custom HTML head -->
        <meta name="view-transition" content="same-origin" />

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="additional.css">
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Rust Programming Language</a></li><li class="chapter-item expanded affix "><a href="foreword.html">들어가기에 앞서</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">소개</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> 시작해봅시다</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> 러스트 설치</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> 카고를 사용해봅시다</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> 추리 게임</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> 일반적인 프로그래밍 개념</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> 변수와 가변성</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> 데이터 타입</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> 함수</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> 주석</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> 제어 흐름문</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> 소유권 이해하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> 소유권이 뭔가요?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> 참조와 대여</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> 슬라이스</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> 구조체로 연관된 데이터를 구조화하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> 구조체 정의 및 인스턴트화</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> 구조체를 사용한 예제 프로그램</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> 메서드 문법</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> 열거형과 패턴 매칭</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> 열거형 정의하기</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> match 제어 흐름 구조</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> if let을 사용한 간결한 제어 흐름</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> 커져 가는 프로젝트를 패키지, 크레이트, 모듈로 관리하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> 패키지와 크레이트</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> 모듈을 정의하여 스코프 및 공개 여부 제어하기</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> 경로를 사용하여 모듈 트리의 아이템 참조하기</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> use 키워드로 경로를 스코프 안으로 가져오기</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> 별개의 파일로 모듈 분리하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> 일반적인 컬렉션</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html" class="active"><strong aria-hidden="true">8.1.</strong> 벡터에 여러 값의 목록 저장하기</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> 문자열에 UTF-8 텍스트 저장하기</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> 해시맵에 서로 연관된 키와 값 저장하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> 에러 처리</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> panic!으로 복구 불가능한 에러 처리하기</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Result로 복구 가능한 에러 처리하기</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic!이냐, panic!이 아니냐, 그것이 문제로다</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> 제네릭 타입, 트레이트, 라이프타임</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> 제네릭 데이터 타입</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> 트레이트로 공통된 동작을 정의하기</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> 라이프타임으로 참조자의 유효성 검증하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> 자동화 테스트 작성하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> 테스트 작성 방법</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> 테스트 실행 방법 제어하기</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> 테스트 조직화</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> I/O 프로젝트: 커맨드 라인 프로그램 만들기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> 커맨드 라인 인수 받기</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> 파일 읽기</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> 모듈성과 에러 처리 향상을 위한 리팩터링</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> 테스트 주도 개발로 라이브러리 기능 개발하기</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> 환경 변수 사용하기</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> 표준 출력 대신 표준 에러로 에러 메시지 작성하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> 함수형 언어의 특성: 반복자와 클로저</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> 클로저: 자신의 환경을 캡처하는 익명 함수</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> 반복자로 일련의 아이템들 처리하기</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> I/O 프로젝트 개선하기</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> 성능 비교하기: 루프 vs. 반복자</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> 카고와 Crates.io 더 알아보기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> 릴리즈 프로필을 통한 빌드 커스터마이징하기</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Crates.io에 크레이트 배포하기</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> 카고 작업공간</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> cargo install로 Crates.io에 있는 바이너리 설치하기</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> 커스텀 명령어로 카고 확장하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> 스마트 포인터</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box&lt;T&gt;를 사용하여 힙에 있는 데이터 가리키기</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Deref 트레이트로 스마트 포인터를 보통의 참조자처럼 취급하기</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Drop 트레이트로 메모리 정리 코드 실행하기</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, 참조 카운트 스마트 포인터</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt;와 내부 가변성 패턴</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> 순환 참조는 메모리 누수를 발생시킬 수 있습니다</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> 겁 없는 동시성</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> 스레드를 이용하여 코드를 동시에 실행하기</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> 메시지 패싱을 사용하여 스레드 간 데이터 전송하기</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> 공유 상태 동시성</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Sync와 Send 트레이트를 이용한 확장 가능한 동시성</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> 러스트의 객체 지향 프로그래밍 기능들</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> 객체 지향 언어의 특성</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> 트레이트 객체를 사용하여 다른 타입의 값 허용하기</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> 객체 지향 디자인 패턴 구현하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> 패턴과 매칭</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> 패턴이 사용될 수 있는 모든 곳</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> 반박 가능성: 패턴이 매칭에 실패할지의 여부</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> 패턴 문법</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> 고급 기능</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> 안전하지 않은 러스트</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> 고급 트레이트</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> 고급 타입</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> 고급 함수와 클로저</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> 매크로</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> 최종 프로젝트: 멀티스레드 웹 서버 구축하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> 싱글스레드 웹 서버 구축하기</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> 싱글스레드 서버를 멀티스레드 서버로 바꾸기</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> 우아한 종료와 정리</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> 부록</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - 키워드</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - 연산자와 기호</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - 파생 가능한 트레이트</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - 유용한 개발 도구</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - 에디션</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - 번역본</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - 러스트가 만들어지는 과정과 ‘Nightly 러스트’</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 프로그래밍 언어</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="벡터에-여러-값의-목록-저장하기"><a class="header" href="#벡터에-여러-값의-목록-저장하기">벡터에 여러 값의 목록 저장하기</a></h2>
<p>첫 번째로 살펴볼 컬렉션 타입은 <em>벡터</em>라고도 하는 <code>Vec&lt;T&gt;</code>입니다. 벡터를
사용하면 메모리에서 모든 값을 서로 이웃하도록 배치하는 단일 데이터 구조에 하나
이상의 값을 저장할 수 있습니다. 벡터는 같은 타입의 값만을 저장할 수 있습니다.
벡터는 파일 내의 텍스트 라인들이나 장바구니의 품목 가격 같은 아이템 목록을
저장하는 상황일 때 유용합니다.</p>
<h3 id="새-벡터-만들기"><a class="header" href="#새-벡터-만들기">새 벡터 만들기</a></h3>
<p>비어있는 새 벡터를 만들려면 다음 예제 8-1과 같이 <code>Vec::new</code> 함수를
호출합니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v: Vec&lt;i32&gt; = Vec::new();
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">예제 8-1: <code>i32</code> 타입의 값을 가질 수 있는 비어있는 새 벡터
생성</span></p>
<p>위에서 타입 명시 (type annotation) 가 추가된 것에 주목하세요. 이 벡터에 어떠한
값도 집어넣지 않았기 때문에, 러스트는 저장하고자 하는 요소가 어떤 타입인지
알지 못합니다. 이는 중요한 지점입니다. 벡터는 제네릭 (generic) 을 이용하여 구현됐습니다;
제네릭을 이용하여 여러분만의 타입을 만드는 방법은 10장에서 다룰 것입니다.
지금 당장은 표준 라이브러리가 제공하는 <code>Vec</code> 타입은 어떠한 타입의 값이라도 저장할
수 있다는 것만 기억해 둡시다. 특정한 타입의 값을 저장할 벡터를 만들 때는
꺾쇠괄호(&lt;&gt;) 안에 해당 타입을 지정합니다. 예제 8-1에서는 러스트에게
<code>v</code>의 <code>Vec</code>이 <code>i32</code> 타입의 요소를 갖는다고 알려주었습니다.</p>
<p>대부분의 경우는 초깃값들과 함께 <code>Vec&lt;T&gt;</code>를 생성하고 러스트는 저장하고자
하는 값의 타입을 대부분 유추할 수 있으므로, 이런 타입 명시를 할 필요가 거의
없습니다. 러스트는 편의를 위해 <code>vec!</code> 매크로를 제공하는데, 이 매크로는
제공된 값들을 저장한 새로운 <code>Vec</code>을 생성합니다. 예제 8-2는 <code>1</code>, <code>2</code>,
<code>3</code>을 저장한 새로운 <code>Vec&lt;i32&gt;</code>을 생성할 것입니다.
3장의 <a href="ch03-02-data-types.html#data-types">‘데이터 타입’</a><!-- ignore -->절에서 본 것처럼,
기본 정수형이 <code>i32</code>기 때문에 여기서도 타입은 <code>i32</code>입니다.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">예제 8-2: 값을 저장하고 있는 새로운 벡터
생성하기</span></p>
<p>러스트는 <code>i32</code> 값이 초깃값으로 설정된 것을 이용해, <code>v</code>의 타입을 <code>Vec&lt;i32&gt;</code>로
추론할 수 있습니다. 따라서 타입 명시는 필요 없습니다. 다음으로는 벡터를
수정하는 방법을 살펴보겠습니다.</p>
<h3 id="벡터-업데이트하기"><a class="header" href="#벡터-업데이트하기">벡터 업데이트하기</a></h3>
<p>벡터를 만들고 여기에 요소를 추가하기 위해서는 다음 예제 8-3처럼
<code>push</code> 메서드를 사용할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = Vec::new();

    v.push(5);
    v.push(6);
    v.push(7);
    v.push(8);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">예제 8-3: <code>push</code> 메서드를 사용하여 벡터에 값을
추가하기</span></p>
<p>3장에서 설명한 것처럼, 어떤 변수의 값을 변경하려면 <code>mut</code> 키워드를 사용하여
해당 변수를 가변으로 만들어야 합니다. 또한 <code>Vec&lt;i32&gt;</code> 타입 명시를 붙이지
않아도 되는 이유는, 집어넣은 숫자가 모두 <code>i32</code> 타입인 점을 통하여
러스트가 <code>v</code>의 타입을 추론하기 때문입니다.</p>
<h3 id="벡터-요소-읽기"><a class="header" href="#벡터-요소-읽기">벡터 요소 읽기</a></h3>
<p>벡터에 저장된 값을 참조하는 방법은 인덱싱과 <code>get</code> 메서드 두 가지가 있습니다.
다음 예제에서는 명료한 전달을 위해 각 함수들이 반환하는 값의 타입을
명시했습니다.</p>
<p>예제 8-4는 인덱스 문법과 <code>get</code> 메서드를 가지고 벡터의 값에
접근하는 두 방법을 모두 보여줍니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3, 4, 5];

    let third: &amp;i32 = &amp;v[2];
    println!(&quot;The third element is {third}&quot;);

    let third: Option&lt;&amp;i32&gt; = v.get(2);
    match third {
        Some(third) =&gt; println!(&quot;The third element is {third}&quot;),
        None =&gt; println!(&quot;There is no third element.&quot;),
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">예제 8-4: 인덱스 문법 혹은 <code>get</code> 메서드를 사용하여
벡터 내의 아이템에 접근하기</span></p>
<p>여기서 주의할 세부 사항이 몇 가지 있습니다. 벡터의 인덱스는 0부터 시작하므로,
세 번째 값을 얻어오기 위해서는 인덱스 값 <code>2</code>를 사용합니다.
<code>&amp;</code>와 <code>[]</code>를 사용하면 인덱스 값에 위치한 요소의 참조자를 얻게 됩니다.
<code>get</code> 함수에 인덱스를 매개변수로 넘기면, <code>match</code>를 통해 처리할 수 있는
<code>Option&lt;&amp;T&gt;</code>를 얻게 됩니다.</p>
<p>러스트가 벡터 요소를 참조하는 방법을 두 가지 제공하는 이유는 벡터에
없는 인덱스 값을 사용하고자 했을 때 프로그램이 어떻게 동작할
것인지 선택할 수 있도록 하기 위해서입니다. 예를 들어, 아래의 예제 8-5와
같이 5개의 요소를 가지고 있는 벡터가 있고 100 인덱스에 있는 요소에
접근을 시도하는 경우 어떤 일이 생기는지 확인해 봅시다:</p>
<pre><pre class="playground"><code class="language-rust should_panic panics"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3, 4, 5];

    let does_not_exist = &amp;v[100];
    let does_not_exist = v.get(100);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">예제 8-5: 5개의 요소를 가진 벡터에 100 인덱스에 있는
요소에 접근하기</span></p>
<p>이 프로그램을 실행하면, 첫 번째의 <code>[]</code> 메서드는 패닉을 일으키는데,
이는 존재하지 않는 요소를 참조하기 때문입니다. 이 방법은 프로그램이
벡터의 끝을 넘어서는 요소에 접근하는 시도를 하면 프로그램이 죽게
만들고 싶은 경우 가장 좋습니다.</p>
<p><code>get</code> 함수에 벡터 범위를 벗어난 인덱스가 주어지면 패닉 없이 <code>None</code>이
반환됩니다. 일반적인 상황에서 벡터의 범위 밖에 있는 요소에 접근하는 일이
종종 발생할 수도 있다면 이 방법을 사용할 만합니다. 이 방법을 사용한다면
6장에서 본 것처럼 <code>Some(&amp;element)</code> 혹은 <code>None</code>에 대해 처리하는 로직이
있어야 합니다. 예를 들어 인덱스는 사람이 직접 번호를 입력하는 것으로
들어올 수도 있습니다. 만일 사용자가 잘못하여 너무 큰 숫자를 입력하여
프로그램이 <code>None</code> 값을 받았을 경우라면 사용자에게 현재 <code>Vec</code>에
몇 개의 아이템이 있으며 유효한 값을 입력할 기회를 다시 한 번 줄 수도
있습니다. 이렇게 하는 편이 오타 때문에 프로그램이 죽는 것보다는 더 사용자
친화적이겠죠?</p>
<p>프로그램에 유효한 참조자가 있다면, 대여 검사기 (borrow checker) 가 (4장에서
다루었던) 소유권 및 대여 규칙을 집행하여 이 참조자와 벡터의 내용물로부터
얻은 다른 참조자들이 계속 유효하게 남아있도록 보장합니다. 같은 스코프에서는
가변 참조자와 불변 참조자를 가질 수 없다는 규칙을 상기하세요.
이 규칙은 아래 예제에서도 적용되는데, 예제 8-6에서는 벡터의 첫 번째
요소에 대한 불변 참조자를 얻은 뒤 벡터의 끝에 요소를 추가하는 시도를
합니다. 함수 끝에서 해당 요소에 대한 참조까지 시도한다면 이 프로그램은 동작하지
않을 것입니다:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5];

    let first = &amp;v[0];

    v.push(6);

    println!(&quot;The first element is: {first}&quot;);
<span class="boring">}</span></code></pre>
<p><span class="caption">예제 8-6: 아이템의 참조자를 가지고 있는 상태에서
벡터에 새로운 요소 추가 시도하기</span></p>
<p>이 예제를 컴파일하면 아래와 같은 에러가 발생합니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:5
  |
4 |     let first = &amp;v[0];
  |                  - immutable borrow occurs here
5 |
6 |     v.push(6);
  |     ^^^^^^^^^ mutable borrow occurs here
7 |
8 |     println!(&quot;The first element is: {first}&quot;);
  |                                      ----- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `collections` due to previous error
</code></pre>
<p>예제 8-6의 코드는 동작해야 할 것처럼 보일 수도 있겠습니다:
첫 번째 요소의 참조자가 벡터 끝부분의 변경이랑 무슨 상관일까요?
이를 이해하기 위해, 잠시 벡터의 동작 방법을 알아보도록 하겠습니다.
벡터는 모든 요소가 서로 붙어서 메모리에 저장됩니다. 그리고 새로운
요소를 벡터 끝에 추가할 경우, 현재 벡터 메모리 위치에 새로운 요소를
추가할 공간이 없다면, 다른 넉넉한 곳에 메모리를 새로 할당하고 기존
요소를 새로 할당한 공간에 복사합니다. 이 경우, 기존 요소의 참조자는
해제된 메모리를 가리키게 되기 때문에, 이러한 상황을 대여 규칙으로
막아둔 것이죠.</p>
<blockquote>
<p>Note: <code>Vec&lt;T&gt;</code> 타입의 구현 세부 사항에 대한 그 밖의 것에 대해서는
<a href="../nomicon/vec/vec.html">‘러스토노미콘 (The Rustonomicon)’</a>을 보세요:</p>
</blockquote>
<h3 id="벡터-값에-대해-반복하기"><a class="header" href="#벡터-값에-대해-반복하기">벡터 값에 대해 반복하기</a></h3>
<p>벡터 내의 각 요소를 차례대로 접근하기 위해서는 인덱스를 사용하여
한 번에 하나의 값에 접근하기보다는 모든 요소에 대한 반복 처리를 합니다.
예제 8-7은 <code>for</code> 루프를 사용하여 <code>i32</code>의 벡터에 있는 각 요소에 대한
불변 참조자를 얻어서 이를 출력하는 방법을 보여줍니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![100, 32, 57];
    for i in &amp;v {
        println!(&quot;{i}&quot;);
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">예제 8-7: <code>for</code> 루프로 벡터의 요소들에 대해
반복하여 각 요소를 출력하기</span></p>
<p>모든 요소를 변경하기 위해서는 가변 벡터의 각 요소에 대한 가변
참조자로 반복 작업을 할 수도 있습니다. 예제 8-8의 <code>for</code> 루프는
각 요소에 <code>50</code>을 더할 것입니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = vec![100, 32, 57];
    for i in &amp;mut v {
        *i += 50;
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">예제 8-8: 벡터의 요소에 대한 가변 참조자로
반복하기</span></p>
<p>가변 참조자가 가리키는 값을 수정하려면,
<code>+=</code> 연산자를 쓰기 전에 <code>*</code> 역참조 연산자로 <code>i</code>의 값을 얻어야 합니다.
역참조 연산자는 15장
<a href="ch15-02-deref.html#following-the-pointer-to-the-value-with-the-dereference-operator">‘포인터를 따라가서 값 얻기’</a>에서
자세히 알아볼 예정입니다.</p>
<p>벡터에 대한 반복 처리는 불변이든 가변이든 상관없이 대여 검사 규칙에
의해 안전합니다. 만일 예제 8-7과 예제 8-8의 <code>for</code> 루프
본문에서 아이템을 추가하거나 지우는 시도를 했다면 예제 8-6의
코드에서 본 것과 유사한 컴파일 에러가 발생하게 됩니다. <code>for</code> 루프가
가지고 있는 벡터에 대한 참조자는 전체 벡터에의 동시다발적 수정을
막습니다.</p>
<h3 id="열거형을-이용해-여러-타입-저장하기"><a class="header" href="#열거형을-이용해-여러-타입-저장하기">열거형을 이용해 여러 타입 저장하기</a></h3>
<p>벡터는 같은 타입을 가진 값들만 저장할 수 있습니다. 이는 불편할
수 있습니다; 다른 타입의 아이템들에 대한 리스트를 저장해야 하는 상황도
분명히 있으니까요. 다행히도, 열거형의 배리언트는 같은 열거형 타입
내에 정의가 되므로, 벡터 내에 다른 타입의 값들을 저장할 필요가 있다면
열거형을 정의하여 사용할 수 있습니다!</p>
<p>예를 들어, 스프레드시트의 행으로부터 값들을 가져오고 싶은데, 여기서 어떤
열은 정수를, 어떤 열은 실수를, 어떤 열은 문자열을 갖고 있다고 해봅시다.
다양한 타입의 값을 갖는 배리언트를 보유한 열거형을 정의할 수 있고,
모든 열거형 배리언트들은 해당 열거형 타입과 같은 타입으로 간주됩니다.
그러면 해당 열거형을 담을 벡터를 생성하여 궁극적으로 다양한 타입을
담을 수 있습니다. 예제 8-9에서 이를 보여주고 있습니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Text(String::from(&quot;blue&quot;)),
        SpreadsheetCell::Float(10.12),
    ];
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">예제 8-9: 열거형을 정의하여 벡터 내에 다른
타입의 데이터를 담을 수 있도록 하기</span></p>
<p>러스트가 컴파일 타임에 벡터 내에 저장될 타입이 무엇인지 알아야 하는
이유는 각 요소를 저장하기 위해 얼마만큼의 힙 메모리가 필요한지 알아야 하기
때문입니다. 또한 이 벡터가 담을 수 있는 타입을 명시적으로 보여줘야 합니다. 만일
러스트가 어떠한 타입이든 담을 수 있는 벡터를 허용한다면, 벡터의 각 요소마다
수행되는 연산에 대해 하나 혹은 그 이상의 타입이 에러를 발생시킬 수도 있습니다.
열거형과 <code>match</code> 표현식을 사용한다는 것은 6장에서 설명한 것처럼 러스트가
컴파일 타임에 가능한 모든 경우를 처리함을 보장해 준다는 뜻입니다.</p>
<p>런타임에 프로그램이 벡터에 저장할 모든 타입 집합을 알지 못하면
열거형을 이용한 방식은 사용할 수 없을 것입니다. 대신 트레이트 객체 (trait object) 를
이용할 수 있는데, 이건 17장에서 다룰 예정입니다.</p>
<p>지금까지 벡터를 이용하는 가장 일반적인 방식 몇 가지를 논의했는데, 표준
라이브러리의 <code>Vec</code>에 정의된 유용한 메서드들이 많이 있으니
<a href="../std/vec/struct.Vec.html">API 문서</a><!-- ignore -->를 꼭 살펴봐 주시기 바랍니다. 예를 들면,
<code>push</code>에 더해서, <code>pop</code> 메서드는 제일 마지막 요소를 반환하고 지워줍니다.</p>
<h3 id="벡터가-버려지면-벡터의-요소도-버려집니다"><a class="header" href="#벡터가-버려지면-벡터의-요소도-버려집니다">벡터가 버려지면 벡터의 요소도 버려집니다</a></h3>
<p><code>struct</code>와 마찬가지로, 예제 8-10에 주석으로 표시된 것처럼
벡터는 스코프를 벗어날 때 해제됩니다.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {
        let v = vec![1, 2, 3, 4];

        // v를 가지고 작업하기
    } // &lt;- 여기서 v가 스코프 밖으로 벗어나고 해제됩니다
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">예제 8-10: 벡터와 요소들이 버려지는 위치를
표시</span></p>
<p>벡터가 버려질 때 벡터의 내용물도 전부 버려집니다. 즉, 벡터가 가지고
있던 정수들의 메모리도 정리됩니다. 대여 검사기는 벡터의 내용물에
대한 참조자의 사용이 해당 벡터가 유효할 때만 발생했는지
확인합니다.</p>
<p>이제 다음 컬렉션 타입인 <code>String</code>으로 넘어갑시다!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch08-00-common-collections.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch08-02-strings.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch08-00-common-collections.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch08-02-strings.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    </body>
</html>
