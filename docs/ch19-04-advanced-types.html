<!DOCTYPE HTML>
<html lang="ko" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>고급 타입 - Rust 프로그래밍 언어</title>


        <!-- Custom HTML head -->
        <meta name="view-transition" content="same-origin" />

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="additional.css">
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Rust Programming Language</a></li><li class="chapter-item expanded affix "><a href="foreword.html">들어가기에 앞서</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">소개</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> 시작해봅시다</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> 러스트 설치</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> 카고를 사용해봅시다</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> 추리 게임</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> 일반적인 프로그래밍 개념</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> 변수와 가변성</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> 데이터 타입</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> 함수</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> 주석</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> 제어 흐름문</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> 소유권 이해하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> 소유권이 뭔가요?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> 참조와 대여</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> 슬라이스</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> 구조체로 연관된 데이터를 구조화하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> 구조체 정의 및 인스턴트화</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> 구조체를 사용한 예제 프로그램</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> 메서드 문법</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> 열거형과 패턴 매칭</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> 열거형 정의하기</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> match 제어 흐름 구조</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> if let을 사용한 간결한 제어 흐름</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> 커져 가는 프로젝트를 패키지, 크레이트, 모듈로 관리하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> 패키지와 크레이트</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> 모듈을 정의하여 스코프 및 공개 여부 제어하기</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> 경로를 사용하여 모듈 트리의 아이템 참조하기</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> use 키워드로 경로를 스코프 안으로 가져오기</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> 별개의 파일로 모듈 분리하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> 일반적인 컬렉션</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> 벡터에 여러 값의 목록 저장하기</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> 문자열에 UTF-8 텍스트 저장하기</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> 해시맵에 서로 연관된 키와 값 저장하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> 에러 처리</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> panic!으로 복구 불가능한 에러 처리하기</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Result로 복구 가능한 에러 처리하기</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic!이냐, panic!이 아니냐, 그것이 문제로다</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> 제네릭 타입, 트레이트, 라이프타임</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> 제네릭 데이터 타입</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> 트레이트로 공통된 동작을 정의하기</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> 라이프타임으로 참조자의 유효성 검증하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> 자동화 테스트 작성하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> 테스트 작성 방법</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> 테스트 실행 방법 제어하기</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> 테스트 조직화</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> I/O 프로젝트: 커맨드 라인 프로그램 만들기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> 커맨드 라인 인수 받기</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> 파일 읽기</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> 모듈성과 에러 처리 향상을 위한 리팩터링</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> 테스트 주도 개발로 라이브러리 기능 개발하기</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> 환경 변수 사용하기</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> 표준 출력 대신 표준 에러로 에러 메시지 작성하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> 함수형 언어의 특성: 반복자와 클로저</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> 클로저: 자신의 환경을 캡처하는 익명 함수</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> 반복자로 일련의 아이템들 처리하기</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> I/O 프로젝트 개선하기</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> 성능 비교하기: 루프 vs. 반복자</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> 카고와 Crates.io 더 알아보기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> 릴리즈 프로필을 통한 빌드 커스터마이징하기</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Crates.io에 크레이트 배포하기</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> 카고 작업공간</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> cargo install로 Crates.io에 있는 바이너리 설치하기</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> 커스텀 명령어로 카고 확장하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> 스마트 포인터</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box&lt;T&gt;를 사용하여 힙에 있는 데이터 가리키기</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Deref 트레이트로 스마트 포인터를 보통의 참조자처럼 취급하기</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Drop 트레이트로 메모리 정리 코드 실행하기</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, 참조 카운트 스마트 포인터</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt;와 내부 가변성 패턴</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> 순환 참조는 메모리 누수를 발생시킬 수 있습니다</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> 겁 없는 동시성</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> 스레드를 이용하여 코드를 동시에 실행하기</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> 메시지 패싱을 사용하여 스레드 간 데이터 전송하기</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> 공유 상태 동시성</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Sync와 Send 트레이트를 이용한 확장 가능한 동시성</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> 러스트의 객체 지향 프로그래밍 기능들</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> 객체 지향 언어의 특성</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> 트레이트 객체를 사용하여 다른 타입의 값 허용하기</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> 객체 지향 디자인 패턴 구현하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> 패턴과 매칭</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> 패턴이 사용될 수 있는 모든 곳</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> 반박 가능성: 패턴이 매칭에 실패할지의 여부</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> 패턴 문법</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> 고급 기능</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> 안전하지 않은 러스트</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> 고급 트레이트</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html" class="active"><strong aria-hidden="true">19.3.</strong> 고급 타입</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> 고급 함수와 클로저</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> 매크로</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> 최종 프로젝트: 멀티스레드 웹 서버 구축하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> 싱글스레드 웹 서버 구축하기</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> 싱글스레드 서버를 멀티스레드 서버로 바꾸기</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> 우아한 종료와 정리</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> 부록</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - 키워드</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - 연산자와 기호</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - 파생 가능한 트레이트</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - 유용한 개발 도구</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - 에디션</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - 번역본</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - 러스트가 만들어지는 과정과 ‘Nightly 러스트’</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 프로그래밍 언어</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="고급-타입"><a class="header" href="#고급-타입">고급 타입</a></h2>
<p>러스트의 타입 시스템에는 지금까지 언급은 했지만 아직 논의하지는 않은
몇 가지 기능이 있습니다. 먼저 뉴타입이 타입으로써 유용한 이유를 살펴보면서
뉴타입에 대해 전반적으로 논의하겠습니다. 그런 다음 뉴타입과 비슷하지만 의미는
약간 다른 기능인 타입 별칭 (type alias) 에 대해 살펴보겠습니다. 또한 <code>!</code>
타입과 동적 크기 타입 (dynamically sized type) 에 대해서도 설명합니다.</p>
<h3 id="타입-안전성과-추상화를-위한-뉴타입-패턴-사용하기"><a class="header" href="#타입-안전성과-추상화를-위한-뉴타입-패턴-사용하기">타입 안전성과 추상화를 위한 뉴타입 패턴 사용하기</a></h3>
<blockquote>
<p>Note: 이 절은 여러분이 이전에 나온
<a href="ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types">‘뉴타입 패턴을 사용하여 외부 타입에 외부 트레이트 구현하기’</a><!-- ignore -->절을
읽었다고 가정합니다.</p>
</blockquote>
<p>뉴타입 패턴은 지금까지 설명한 것 이외의 작업에도 유용한데, 여기에는
값이 혼동되지 않도록 정적으로 강제하는 것과 값의 단위를 표시하는
것들이 포함됩니다. 예제 19-15에서 뉴타입을 사용하여 단위를 표시하는
예제를 보았습니다: <code>Millimeters</code> 및 <code>Meters</code> 구조체가 <code>u32</code> 값을
뉴타입으로 감싸고 있었음을 상기하세요. <code>Millimeters</code> 타입의
매개변수가 있는 함수를 작성했다면, 실수로 <code>Meters</code> 또는 보통의
<code>u32</code> 타입의 값으로 해당 함수를 호출 시도하는 프로그램은 컴파일될
수 없습니다.</p>
<p>뉴타입 패턴은 어떤 타입의 구현 세부 사항을 추상화하는데도
사용 가능합니다: 뉴타입은 비공개 내부 타입의 API와는 다른 공개
API를 노출할 수 있습니다.</p>
<p>뉴타입은 내부 구현을 숨길 수도 있습니다. 예를 들면, 어떤 사람의 ID와
이에 연관된 그 사람의 이름을 저장하는 <code>HashMap&lt;i32, String&gt;</code>을
감싼 <code>People</code> 타입을 만들 수 있습니다. <code>People</code>을 사용하는
코드는 <code>People</code> 컬렉션에 이름 문자열을 추가하는 메서드처럼
우리가 제공하는 공개 API와만 상호작용할 수 있습니다; 해당
코드는 내부적으로 이름에 <code>i32</code> ID를 할당한다는 사실을 알 필요가
없습니다. 뉴타입 패턴은 구현 세부 사항을 숨기는 캡슐화를 달성하는
가벼운 방법으로, 17장의
<a href="ch17-01-what-is-oo.html#encapsulation-that-hides-implementation-details">‘상세 구현을 은닉하는 캡슐화’</a><!-- ignore -->절에서
설명한 바 있습니다.</p>
<h3 id="타입-별칭으로-타입의-동의어-만들기"><a class="header" href="#타입-별칭으로-타입의-동의어-만들기">타입 별칭으로 타입의 동의어 만들기</a></h3>
<p>러스트는 <em>타입 별칭 (type alias)</em> 을 선언하여 기존 타입에 다른 이름을 부여하는
기능을 제공합니다. 이를 위해서는 <code>type</code> 키워드를 사용합니다. 예를 들어, 다음과
같이 <code>i32</code>에 대한 <code>Kilometers</code>라는 별칭을 만들 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    type Kilometers = i32;
<span class="boring">
</span><span class="boring">    let x: i32 = 5;
</span><span class="boring">    let y: Kilometers = 5;
</span><span class="boring">
</span><span class="boring">    println!(&quot;x + y = {}&quot;, x + y);
</span><span class="boring">}</span></code></pre></pre>
<p>이제 별칭 <code>Kilometers</code>는 <code>i32</code>의 <em>동의어</em>입니다; 예제 19-15에서
만든 <code>Millimeters</code> 및 <code>Meters</code> 타입과는 달리, <code>Kilometers</code>는 별도의
새로운 타입은 아닙니다. <code>Kilometers</code> 타입을 가진 값은 <code>i32</code> 타입의 값과
동일하게 처리됩니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    type Kilometers = i32;

    let x: i32 = 5;
    let y: Kilometers = 5;

    println!(&quot;x + y = {}&quot;, x + y);
<span class="boring">}</span></code></pre></pre>
<p><code>Kilometers</code>와 <code>i32</code>는 동일한 타입이므로 두 타입의 값을 모두 더할
수 있고 <code>Kilometers</code> 값을 <code>i32</code> 매개변수를 받는 함수에 전달할 수
있습니다. 그러나, 이 방법을 사용하면 이전에 설명한 뉴타입 패턴에서
얻을 수 있는 타입 검사 이점을 얻을 수 없습니다. 다시 말해, 어딘가에서
<code>Kilometers</code>와 <code>i32</code> 값을 혼용하면 컴파일러는 에러를 표시하지
않습니다.</p>
<p>타입 동의어의 주요 사용 사례는 반복을 줄이는 것입니다. 예를 들어,
다음과 같은 긴 타입이 있을 수 있습니다:</p>
<pre><code class="language-rust ignore">Box&lt;dyn Fn() + Send + 'static&gt;</code></pre>
<p>이 긴 타입을 함수 시그니처 및 코드의 모든 곳에 타입 명시로 작성하는
것은 지루하고 에러가 발생하기 쉽습니다. 예제 19-24와 같은 코드로
가득 찬 프로젝트가 있다고 상상해 보세요.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let f: Box&lt;dyn Fn() + Send + 'static&gt; = Box::new(|| println!(&quot;hi&quot;));

    fn takes_long_type(f: Box&lt;dyn Fn() + Send + 'static&gt;) {
        // --생략--
    }

    fn returns_long_type() -&gt; Box&lt;dyn Fn() + Send + 'static&gt; {
        // --생략--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">예제 19-24: 수많은 곳에 긴 타입 사용하기</span></p>
<p>타입 별칭은 반복을 줄여 이 코드를 관리하기 쉽게 만듭니다. 예제 19-25에서는
이 장황한 타입에 대해 <code>Thunk</code>라는 별칭을 만들고 이 타입이
사용된 모든 곳을 짧은 별칭 <code>Thunk</code>로 대체했습니다.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    type Thunk = Box&lt;dyn Fn() + Send + 'static&gt;;

    let f: Thunk = Box::new(|| println!(&quot;hi&quot;));

    fn takes_long_type(f: Thunk) {
        // --생략--
    }

    fn returns_long_type() -&gt; Thunk {
        // --생략--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">예제 19-25: 타입 별칭 <code>Thunk</code>을 도입하여
반복 줄이기</span></p>
<p>이 코드는 읽고 작성하기 훨씬 쉽습니다! 또한 타입 별칭에 의미 있는
이름을 선택하면 의도를 전달하는 데 도움이 됩니다. (<em>thunk</em>는
나중에 평가될 코드를 나타내는 단어이므로, 저장되는 클로저에 적합한
이름입니다.)</p>
<p>타입 별칭은 또한 <code>Result&lt;T, E&gt;</code> 타입의 반복을 줄이기 위해 사용되기도
합니다. 표준 라이브러리의 <code>std::io</code> 모듈을 생각해 보세요. I/O 연산은
종종 연산이 작동하지 않을 때의 상황을 처리하기 위해 <code>Result&lt;T, E&gt;</code>를
반환합니다. 이 라이브러리에는 가능한 모든 I/O 에러를 나타내는
<code>std::io::Error</code> 구조체가 있습니다. <code>std::io</code>의 많은 함수는 <code>Write</code>
트레이트의 함수와 같이 <code>E</code>가 <code>std::io::Error</code>인 <code>Result&lt;T, E&gt;</code>를
반환합니다:</p>
<pre><code class="language-rust noplayground">use std::fmt;
use std::io::Error;

pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;
}</code></pre>
<p><code>Result&lt;..., Error&gt;</code>가 많이 반복됩니다. 이러한 이유로 <code>std::io</code>에는
이러한 타입 별칭 선언이 있습니다:</p>
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span>type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
<span class="boring">
</span><span class="boring">pub trait Write {
</span><span class="boring">    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
</span><span class="boring">    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;
</span><span class="boring">
</span><span class="boring">    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
</span><span class="boring">    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
</span><span class="boring">}</span></code></pre>
<p>이 선언이 <code>std::io</code> 모듈에 있으므로, 완전 정규화된 별칭
<code>std::io::Result&lt;T&gt;</code>를 사용할 수 있습니다; 즉, <code>E</code>가
<code>std::io::Error</code>로 채워진 <code>Result&lt;T, E&gt;</code>입니다. <code>Write</code> 트레이트
함수 시그니처는 결국 다음과 같이 생기게 됩니다:</p>
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
</span><span class="boring">
</span>pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
}</code></pre>
<p>타입 별칭은 두 가지 방법으로 도움을 줍니다: 코드를 쉽게 작성할 수 있게 해 주고,
<em>그러면서도</em> <code>std::io</code> 전체에 일관된 인터페이스를 제공합니다. 이것은 별칭이기
때문에 그저 또 다른 <code>Result&lt;T, E&gt;</code>일 뿐이고, 이는 <code>Result&lt;T, E&gt;</code>에서 작동하는
모든 메서드는 물론, <code>?</code> 연산자와 같은 특별 문법도 사용할 수 있음을 뜻합니다.</p>
<h3 id="절대-반환하지-않는-부정-타입"><a class="header" href="#절대-반환하지-않는-부정-타입">절대 반환하지 않는 부정 타입</a></h3>
<p>러스트에는 <code>!</code>라는 특수한 타입이 있는데, 이 타입은 값이 없기 때문에 타입
이론 용어로는 <em>빈 타입 (empty type)</em> 이라고 알려져 있습니다. 함수가 절대
반환하지 않을 때 반환 타입을 대신하기 때문에 <em>부정 타입 (never type)</em> 이라고
부르는 쪽이 선호됩니다. 다음은 예시입니다:</p>
<pre><code class="language-rust noplayground">fn bar() -&gt; ! {
    // --생략--
<span class="boring">    panic!();
</span>}</code></pre>
<p>이 코드는 ‘함수 <code>bar</code>는 절대로 반환하지 않습니다’라고 읽습니다. 절대로 반환하지
않는 함수는 <em>발산 함수 (diverging functions)</em> 라고 합니다. <code>!</code> 타입의 값은
만들 수 없으므로, <code>bar</code>는 절대 반환할 수 없습니다.</p>
<p>그런데 값을 절대로 만들 수 없는 타입은 어디에 쓰는 거죠? 숫자 추리 게임의
부분인 예제 2-5의 코드를 기억해 보세요; 여기에 예제 19-26에서
다시 일부를 재현해 두었습니다.</p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        // --생략--
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span>        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };
<span class="boring">
</span><span class="boring">        println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">
</span><span class="boring">        // --생략--
</span><span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;You win!&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">예제 19-26: <code>continue</code>로 끝나는 갈래가
있는 <code>match</code></span></p>
<p>이 시점에서는 이 코드에서 몇 가지 세부 사항을 건너뛰었습니다. 6장의
<a href="ch06-02-match.html#the-match-control-flow-operator">‘<code>match</code> 제어 흐름 연산자’</a><!-- ignore -->절에서
<code>match</code> 갈래가 모두 같은 타입을 반환해야 한다는 것을 논의했습니다. 예를 들어,
다음 코드는 작동하지 않습니다:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let guess = &quot;3&quot;;
</span>    let guess = match guess.trim().parse() {
        Ok(_) =&gt; 5,
        Err(_) =&gt; &quot;hello&quot;,
    };
<span class="boring">}</span></code></pre>
<p><code>guess</code>의 타입은 정수 <em>그리고</em> 문자열이어야 하며, 러스트는
<code>guess</code>가 하나의 타입만 가져야 한다고 요구합니다. 그럼 <code>continue</code>가
무엇을 반환할까요? 어떻게 예제 19-26에서 한쪽 갈래는 <code>u32</code>를
반환하면서 다른 갈래는 <code>continue</code>로 끝나는 것이 허용되었을까요?</p>
<p>짐작하셨겠지만, <code>continue</code>는 <code>!</code> 값을 가집니다. 즉, 러스트가 <code>guess</code>의
타입을 계산할 때, 두 개의 매치 갈래를 모두 살펴보게 되는데, 전자는 <code>u32</code> 값을
가지고 후자는 <code>!</code> 값을 가집니다. <code>!</code>는 절대로 값을 가질 수 없으므로, 러스트는
<code>guess</code>의 타입이 <code>u32</code>라고 결정합니다.</p>
<p>이 동작을 설명하는 공식적인 방법은 <code>!</code> 타입의 표현식이 다른 모든 타입으로
강제 변환될 수 있다는 것입니다. <code>continue</code>가 값을 반환하지 않기 때문에,
이 <code>match</code> 갈래가 <code>continue</code>로 끝나도 괜찮습니다; <code>continue</code>는 제어를
반복문의 맨 위로 이동시키기 때문에, <code>Err</code> 케이스에서는 <code>guess</code>에 값을
할당하지 않습니다.</p>
<p>부정 타입은 <code>panic!</code> 매크로와 함께 유용하게 쓰입니다. 값을 생성하거나
패닉을 일으키기 위해 <code>Option&lt;T&gt;</code> 값에서 호출한 <code>unwrap</code> 함수를 기억해
보시면, 여기 그 정의가 있습니다:</p>
<pre><code class="language-rust ignore"><span class="boring">enum Option&lt;T&gt; {
</span><span class="boring">    Some(T),
</span><span class="boring">    None,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::Option::*;
</span><span class="boring">
</span>impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!(&quot;called `Option::unwrap()` on a `None` value&quot;),
        }
    }
}</code></pre>
<p>이 코드에서도 예제 19-26의 <code>match</code>에서와 같은 일이 발생합니다: <code>val</code>이
<code>T</code> 타입을 가지고 있고 <code>panic!</code>이 <code>!</code> 타입을 가지고 있으므로, 러스트는 전체
<code>match</code> 표현식의 결과가 <code>T</code>라는 것을 알 수 있습니다. 이 코드는 <code>panic!</code>이
값을 생성하지 않기 때문에 작동합니다; 패닉은 프로그램을 종료하니까요. <code>None</code>의
경우 <code>unwrap</code>에서 값을 반환하지 않으므로, 이 코드는 유효합니다.</p>
<p><code>!</code> 타입을 가지는 마지막 표현식은 <code>loop</code>입니다:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    print!(&quot;forever &quot;);

    loop {
        print!(&quot;and ever &quot;);
    }
<span class="boring">}</span></code></pre>
<p>여기서 루프는 절대 끝나지 않으므로, <code>!</code>가 이 표현식의 값이 됩니다. 하지만
<code>break</code>를 포함시키면, 루프는 <code>break</code>에 도달했을 때 종료되므로, 이는
참이 아니게 될 것입니다.</p>
<h3 id="동적-크기-타입과-sized-트레이트"><a class="header" href="#동적-크기-타입과-sized-트레이트">동적 크기 타입과 <code>Sized</code> 트레이트</a></h3>
<p>러스트는 특정 타입의 값에 할당할 공간의 크기 등 타입에 대한 특정 세부
사항을 알아야 합니다. 이로 인해 처음에는 타입 시스템의 한구석이 약간
혼란스럽습니다: 바로 <em>동적 크기 타입 (dynamically sized type)</em> 의 개념이 그렇습니다.
<em>DST</em> 또는 <em>크기가 지정되지 않은 타입 (unsized type)</em> 이라고도 하는 이러한 타입을
사용하면 런타임에만 크기를 알 수 있는 값을 사용하여 코드를 작성할 수 있습니다.</p>
<p>이 책 전체에 걸쳐 사용했던 <code>str</code>이라는 동적 크기 타입에 대해 자세히
알아보겠습니다. 그렇습니다. <code>&amp;str</code>이 아니라 <code>str</code> 자체는 DST입니다.
런타임이 될 때까지 문자열의 길이를 알 수 없으므로 <code>str</code> 타입의 변수를
만들 수도 없고, <code>str</code> 타입의 인수를 받을 수도 없습니다. 아래의
작동하지 않는 코드를 고려해 보세요:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1: str = &quot;Hello there!&quot;;
    let s2: str = &quot;How's it going?&quot;;
<span class="boring">}</span></code></pre>
<p>러스트는 특정 타입의 값에 할당할 메모리의 크기를 알아야 하며,
타입의 모든 값은 동일한 크기의 메모리를 사용해야 합니다. 러스트에서
이 코드를 작성할 수 있다면 이 두 <code>str</code> 값은 같은 양의 공간을 차지해야
합니다. 그러나 이들은 길이가 다릅니다: <code>s1</code>은 12바이트의 저장 공간이
필요하고 <code>s2</code>는 15바이트가 필요하기 때문입니다. 이것이 바로 동적 크기를
갖는 변수를 생성할 수 없는 이유입니다.</p>
<p>그럼 어떻게 해야 할까요? 이 경우에는 이미 답을 알고 있습니다: <code>s1</code>과
<code>s2</code>의 타입을 <code>str</code>이 아닌 <code>&amp;str</code>로 만듭니다. 4장의
<a href="ch04-03-slices.html#string-slices">‘문자열 슬라이스’</a><!-- ignore -->절에서 슬라이스
데이터 구조는 슬라이스의 시작 위치와 길이만 저장한다는 것을 기억하세요.
따라서 <code>&amp;T</code>는 <code>T</code>가 위치한 메모리 주소를 저장하는 단일 값이지만,
<code>&amp;str</code>은 <em>두 개의</em> 값입니다: <code>str</code>의 주소와 길이 말이지요. 따라서
컴파일 타임에 <code>&amp;str</code> 값의 크기를 알 수 있습니다: <code>usize</code> 길이의
두 배입니다. 즉, <code>&amp;str</code>이 참조하는 문자열의 길이가 아무리 길어도
항상 <code>&amp;str</code>의 크기를 알 수 있습니다. 일반적으로 이것이 러스트에서
동적 크기 타입이 사용되는 방식입니다: 이들은 동적 정보의 크기를
저장하는 추가 메타데이터를 가지고 있습니다. 동적 크기 타입의
황금률은 동적 크기 타입의 값을 항상 어떤 종류의 포인터 뒤에 넣어야
한다는 것입니다.</p>
<p><code>str</code>은 모든 종류의 포인터와 결합할 수 있습니다: 예를 들면, <code>Box&lt;str&gt;</code>나 <code>Rc&lt;str&gt;</code>
같은 것들이지요. 사실, 여러분은 이전에도 다른 종류의 동적 크기 타입이지만
이런 것을 본 적이 있습니다: 바로 트레이트입니다. 모든 트레이트는 그 트레이트의 이름을
사용하여 참조할 수 있는 동적 크기 타입입니다. 17장의
<a href="ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">‘트레이트 객체를 사용하여 다른 타입의 값 허용하기’</a><!-- ignore -->절에서,
트레이트를 트레이트 객체로 사용하려면
<code>&amp;dyn Trait</code> 또는 <code>Box&lt;dyn Trait&gt;</code>와
같은 포인터 뒤에 넣어야 한다고 언급했습니다. (<code>Rc&lt;dyn Trait&gt;</code>도
가능합니다.)</p>
<p>DST로 작업하기 위해 러스트에서는 컴파일 시점에 타입의 크기를 알 수
있는지 여부를 결정하는 <code>Sized</code> 트레이트를 제공합니다. 이 트레이트는
컴파일 시 크기가 알려진 모든 것에 대해 자동으로 구현됩니다. 또한
러스트는 암묵적으로 모든 제네릭 함수에 <code>Sized</code> 바운드를 추가합니다.
즉, 다음과 같은 제네릭 함수 정의는:</p>
<pre><code class="language-rust ignore">fn generic&lt;T&gt;(t: T) {
    // --생략--
}</code></pre>
<p>실제로는 아래와 같이 작성한 것처럼 취급됩니다:</p>
<pre><code class="language-rust ignore">fn generic&lt;T: Sized&gt;(t: T) {
    // --생략--
}</code></pre>
<p>기본적으로 제네릭 함수는 컴파일 시점에 크기가 알려진 타입에 대해서만
작동합니다. 그러나 다음과 같은 특별 문법을 사용하여 이 제한을 완화할
수 있습니다:</p>
<pre><code class="language-rust ignore">fn generic&lt;T: ?Sized&gt;(t: &amp;T) {
    // --생략--
}</code></pre>
<p><code>?Size</code> 트레이트 바운드는 ‘<code>T</code>는 <code>Sized</code>일 수도 있고 아닐 수도 있다’는 의미를
가지며 이 문법은 제네릭 타입이 컴파일 시점에 크기가 알려진 타입이어야 한다는
기본값을 덮어씁니다. 이런 의미의 <code>?Trait</code> 문법은 <code>Sized</code>에만 사용할 수 있고
다른 어떤 트레이트에도 사용할 수 없습니다.</p>
<p>또한 <code>t</code> 매개변수의 타입을 <code>T</code>에서 <code>&amp;T</code>로 바꾸었음을 주목하세요.
타입이 <code>Sized</code>가 아닐 수 있기 때문에 어떤 종류의 포인터 뒤에 놓고
사용해야 합니다. 이 경우에는 참조를 선택했습니다.</p>
<p>다음으로는 함수와 클로저에 대해 이야기해 보겠습니다!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch19-03-advanced-traits.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch19-05-advanced-functions-and-closures.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch19-03-advanced-traits.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch19-05-advanced-functions-and-closures.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    </body>
</html>
