<!DOCTYPE HTML>
<html lang="ko" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>C - 파생 가능한 트레이트 - Rust 프로그래밍 언어</title>


        <!-- Custom HTML head -->
        <meta name="view-transition" content="same-origin" />

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="additional.css">
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Rust Programming Language</a></li><li class="chapter-item expanded affix "><a href="foreword.html">들어가기에 앞서</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">소개</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> 시작해봅시다</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> 러스트 설치</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> 카고를 사용해봅시다</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> 추리 게임</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> 일반적인 프로그래밍 개념</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> 변수와 가변성</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> 데이터 타입</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> 함수</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> 주석</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> 제어 흐름문</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> 소유권 이해하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> 소유권이 뭔가요?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> 참조와 대여</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> 슬라이스</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> 구조체로 연관된 데이터를 구조화하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> 구조체 정의 및 인스턴트화</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> 구조체를 사용한 예제 프로그램</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> 메서드 문법</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> 열거형과 패턴 매칭</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> 열거형 정의하기</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> match 제어 흐름 구조</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> if let을 사용한 간결한 제어 흐름</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> 커져 가는 프로젝트를 패키지, 크레이트, 모듈로 관리하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> 패키지와 크레이트</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> 모듈을 정의하여 스코프 및 공개 여부 제어하기</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> 경로를 사용하여 모듈 트리의 아이템 참조하기</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> use 키워드로 경로를 스코프 안으로 가져오기</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> 별개의 파일로 모듈 분리하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> 일반적인 컬렉션</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> 벡터에 여러 값의 목록 저장하기</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> 문자열에 UTF-8 텍스트 저장하기</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> 해시맵에 서로 연관된 키와 값 저장하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> 에러 처리</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> panic!으로 복구 불가능한 에러 처리하기</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Result로 복구 가능한 에러 처리하기</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic!이냐, panic!이 아니냐, 그것이 문제로다</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> 제네릭 타입, 트레이트, 라이프타임</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> 제네릭 데이터 타입</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> 트레이트로 공통된 동작을 정의하기</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> 라이프타임으로 참조자의 유효성 검증하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> 자동화 테스트 작성하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> 테스트 작성 방법</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> 테스트 실행 방법 제어하기</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> 테스트 조직화</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> I/O 프로젝트: 커맨드 라인 프로그램 만들기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> 커맨드 라인 인수 받기</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> 파일 읽기</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> 모듈성과 에러 처리 향상을 위한 리팩터링</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> 테스트 주도 개발로 라이브러리 기능 개발하기</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> 환경 변수 사용하기</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> 표준 출력 대신 표준 에러로 에러 메시지 작성하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> 함수형 언어의 특성: 반복자와 클로저</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> 클로저: 자신의 환경을 캡처하는 익명 함수</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> 반복자로 일련의 아이템들 처리하기</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> I/O 프로젝트 개선하기</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> 성능 비교하기: 루프 vs. 반복자</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> 카고와 Crates.io 더 알아보기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> 릴리즈 프로필을 통한 빌드 커스터마이징하기</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Crates.io에 크레이트 배포하기</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> 카고 작업공간</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> cargo install로 Crates.io에 있는 바이너리 설치하기</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> 커스텀 명령어로 카고 확장하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> 스마트 포인터</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box&lt;T&gt;를 사용하여 힙에 있는 데이터 가리키기</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Deref 트레이트로 스마트 포인터를 보통의 참조자처럼 취급하기</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Drop 트레이트로 메모리 정리 코드 실행하기</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, 참조 카운트 스마트 포인터</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt;와 내부 가변성 패턴</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> 순환 참조는 메모리 누수를 발생시킬 수 있습니다</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> 겁 없는 동시성</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> 스레드를 이용하여 코드를 동시에 실행하기</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> 메시지 패싱을 사용하여 스레드 간 데이터 전송하기</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> 공유 상태 동시성</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Sync와 Send 트레이트를 이용한 확장 가능한 동시성</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> 러스트의 객체 지향 프로그래밍 기능들</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> 객체 지향 언어의 특성</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> 트레이트 객체를 사용하여 다른 타입의 값 허용하기</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> 객체 지향 디자인 패턴 구현하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> 패턴과 매칭</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> 패턴이 사용될 수 있는 모든 곳</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> 반박 가능성: 패턴이 매칭에 실패할지의 여부</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> 패턴 문법</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> 고급 기능</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> 안전하지 않은 러스트</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> 고급 트레이트</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> 고급 타입</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> 고급 함수와 클로저</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> 매크로</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> 최종 프로젝트: 멀티스레드 웹 서버 구축하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> 싱글스레드 웹 서버 구축하기</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> 싱글스레드 서버를 멀티스레드 서버로 바꾸기</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> 우아한 종료와 정리</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> 부록</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - 키워드</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - 연산자와 기호</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html" class="active"><strong aria-hidden="true">21.3.</strong> C - 파생 가능한 트레이트</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - 유용한 개발 도구</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - 에디션</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - 번역본</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - 러스트가 만들어지는 과정과 ‘Nightly 러스트’</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 프로그래밍 언어</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="부록-c-파생-가능한-트레이트"><a class="header" href="#부록-c-파생-가능한-트레이트">부록 C: 파생 가능한 트레이트</a></h2>
<p>이 책의 여러 곳에서 구조체나 열거형 정의에 적용할 수 있는
<code>derive</code> 속성에 대해 설명했습니다. <code>derive</code> 속성은 <code>derive</code>
문법으로 명시한 타입에 대해 자체적인 기본 구현이 있는 트레이트를
구현하는 코드를 생성합니다.</p>
<p>이 부록에서는 <code>derive</code>와 함께 사용할 수 있는 표준 라이브러리의 모든 트레이트에
대한 참고 자료를 제공합니다. 각 절이 다룰 내용은 다음과 같습니다:</p>
<ul>
<li>이 트레이트를 파생하면 어떤 연산자와 메서드가 활성화되는지</li>
<li><code>derive</code>가 제공하는 트레이트의 구현체가 하는 일</li>
<li>타입에 대해 트레이트를 구현한다는 것의 의미</li>
<li>트레이트를 구현할 수 있는 조건 혹은 허용되지 않는 조건</li>
<li>트레이트가 필요한 연산들의 예</li>
</ul>
<p><code>derive</code> 속성이 제공하는 것과는 다른 동작을 원한다면, 각 트레이트에 대한
<a href="../std/index.html">표준 라이브러리 문서</a><!-- ignore -->를 참고하여
수동으로 구현하는 방법에 대한 자세한 내용을 확인하세요.</p>
<p>여기에 나열된 트레이트들은 표준 라이브러리에서 <code>derive</code>를 사용하여
타입에 구현할 수 있는 유일한 트레이트들입니다. 표준 라이브러리에
정의된 다른 트레이트에는 적절한 기본 동작이 없으므로, 달성하려는
목적에 적합한 방식으로 구현하는 것은 여러분의 몫입니다.</p>
<p>파생될 수 없는 트레이트의 예로는 <code>Display</code>가 있는데, 이는 최종 사용자를
위한 서식을 처리합니다. 여러분은 최종 사용자에게 타입을 표시할 적절한
방법을 항상 고려해야 합니다. 최종 사용자에게 어떤 부분을 표시해야
할까요? 어떤 부분이 관련성이 있을까요? 어떤 형식의 데이터가 가장
관련성이 높을까요? 러스트 컴파일러에는 이러한 인사이트가 없으므로
적절한 기본 동작을 제공할 수 없습니다.</p>
<p>이 부록에 나열된 트레이트가 파생 가능한 트레이트를 전부 포괄하지는 않습니다:
라이브러리는 자신의 트레이트에 대해 대한 <code>derive</code>를 구현할 수 있으므로,
<code>derive</code>를 사용할 수 있는 트레이트 목록은 정말 개방적입니다. <code>derive</code>를
구현하려면 절차적 매크로를 사용해야 하며, 이는 19장의
<a href="ch19-06-macros.html#macros">‘매크로’</a><!-- ignore -->절에서 다룹니다.</p>
<h3 id="프로그래머-출력을-위한-debug"><a class="header" href="#프로그래머-출력을-위한-debug">프로그래머 출력을 위한 <code>Debug</code></a></h3>
<p><code>Debug</code> 트레이트는 형식 문자열에서 디버그 서식을 활성화하는데, 이는 <code>{}</code>
자리표시자 내에 <code>:?</code>를 추가하여 표시합니다.</p>
<p><code>Debug</code> 트레이트는 디버깅 목적으로 어떤 타입의 인스턴스를 출력할 수 있게
해주므로, 여러분과 여러분의 타입을 사용하는 다른 프로그래머들은 프로그램의
실행 중 특정 지점에서 인스턴스를 검사할 수 있습니다.</p>
<p><code>Debug</code> 트레이트는 이를테면 <code>assert_eq!</code> 매크로를 사용할 때 필요합니다.
이 매크로는 동등 단언이 실패했을 경우 인스턴스의 값을 출력하여 프로그래머가
두 인스턴스가 같지 않은 이유를 확인할 수 있도록 해 줍니다.</p>
<h3 id="동등-비교를-위한-partialeq-및-eq"><a class="header" href="#동등-비교를-위한-partialeq-및-eq">동등 비교를 위한 <code>PartialEq</code> 및 <code>Eq</code></a></h3>
<p><code>PartialEq</code> 트레이트는 타입의 인스턴스를 비교하여 동등 여부를 확인하고
<code>==</code>와 <code>!=</code> 연산자를 사용할 수 있게 해 줍니다.</p>
<p><code>PartialEq</code>를 파생시키면 <code>eq</code> 메서드가 구현됩니다. <code>PartialEq</code>가 구조체에
파생되면, 두 인스턴스는 <em>모든</em> 필드가 동일할 때만 동일하고, 필드 중 어느
하나라도 동일하지 않다면 두 인스턴스는 동일하지 않습니다. 열거형에 파생되면,
각 배리언트는 자기 자신과는 동일하고 다른 변형과는 동일하지 않습니다.</p>
<p>예를 들면 <code>PartialEq</code> 트레이트는 <code>assert_eq!</code> 매크로를 사용할 때 필요한데,
이 매크로는 두 인스턴스를 비교하여 동등 여부를 확인할 수 있어야 하기
때문입니다.</p>
<p><code>Eq</code> 트레이트에는 메서드가 없습니다. 이 트레이트의 목적은 어노테이션된 타입의
모든 값에 대해 해당 값이 자기 자신과 동일하다는 것을 나타내는 것입니다. <code>Eq</code>
트레이트는 <code>PartialEq</code>를 구현한 모든 타입에 적용할 수 있지만, <code>PartialEq</code>를
구현한 모든 타입이 <code>Eq</code>를 구현할 수 있는 것은 아닙니다. 이에 대한 한 가지
예는 부동 소수점 숫자 타입입니다: 부동 소수점 숫자 구현은 not-a-number(<code>NaN</code>)
값의 두 인스턴스가 서로 동일하지 않다고 명시합니다.</p>
<p><code>Eq</code>가 필요한 예시로는 <code>HashMap&lt;K, V&gt;</code>의 키로서, <code>HashMap&lt;K, V&gt;</code>가 두
키가 동일한지 여부를 알 수 있도록 하는 것입니다.</p>
<h3 id="순서-비교를-위한-partialord-및-ord"><a class="header" href="#순서-비교를-위한-partialord-및-ord">순서 비교를 위한 <code>PartialOrd</code> 및 <code>Ord</code></a></h3>
<p><code>PartialOrd</code> 트레이트는 정렬 목적을 위하여 타입의 인스턴스를 비교할 수 있게
해줍니다. <code>PartialOrd</code>를 구현한 타입은 <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> 연산자를
사용할 수 있습니다. <code>PartialOrd</code> 트레이트는 <code>PartialEq</code>를 구현한 타입에만
적용할 수 있습니다.</p>
<p><code>PartialOrd</code> 트레이트를 파생시키면 <code>partial_cmp</code> 메서드가 구현되는데, 이는
<code>Option&lt;Ordering&gt;</code>을 반환하며, 반환 값은 주어진 값이 순서를 정의하지 않을
때 <code>None</code>이 됩니다. 이 트레이트를 구현한 타입의 대부분의 값은 비교할 수
있지만, 순서를 정의하지 않는 값의 예가 있다면 not-a-number (<code>NaN</code>) 부동
소수점 값입니다. <code>NaN</code> 부동 소수점 숫자와 어떤 부동 소수점 숫자를 사용하여
<code>partial_cmp</code>를 호출하면 <code>None</code>이 반환될 것입니다.</p>
<p>구조체에 대해 파생되면, <code>PartialOrd</code>는 구조체 정의에서 필드가 나타나는
순서대로 각 필드의 값을 비교하는 방식으로 두 인스턴스를 비교합니다.
열거형에 대해 파생되면, 열거형 정의에서 먼저 선언된 배리언트는 나중에
선언된 배리언트보다 작다고 간주됩니다.</p>
<p>예를 들면 <code>PartialOrd</code> 트레이트는 범위 표현식에 의해 지정된 범위
내에서 임의의 값을 생성하는 <code>rand</code> 크레이트의 <code>gen_range</code> 메서드를
사용할 때 필요합니다.</p>
<p><code>Ord</code> 트레이트는 어떤 두 값에 대해 항상 유효한 순서가 존재한다는 것을
알려줍니다. <code>Ord</code> 트레이트는 <code>cmp</code> 메서드를 구현하는데, 이는 <code>Option&lt;Ordering&gt;</code>
이 아닌 <code>Ordering</code>을 반환합니다. 이는 항상 유효한 순서가 존재하기 때문입니다.
<code>Ord</code> 트레이트는 <code>PartialOrd</code>와 <code>Eq</code>를 구현한 타입에만 적용할 수 있습니다.
(<code>Eq</code>는 <code>PartialEq</code>를 필요로 합니다.) 구조체와 열거형에 대해 파생되면,
<code>cmp</code>는 <code>PartialOrd</code>의 <code>partial_cmp</code>에 대한 파생 구현체가 동작하는
방식과 동일하게 동작합니다.</p>
<p><code>Ord</code>가 필요한 한 가지 예는 <code>BTreeSet&lt;T&gt;</code>에 값을 저장할 때인데, 이는
값의 정렬 순서에 따라 데이터를 저장하는 데이터 구조입니다.</p>
<h3 id="값을-복제하기-위한-clone과-copy"><a class="header" href="#값을-복제하기-위한-clone과-copy">값을 복제하기 위한 <code>Clone</code>과 <code>Copy</code></a></h3>
<p><code>Clone</code> 트레이트는 명시적으로 값의 깊은 복사 (deep copy) 를 생성할 수 있게
해주며, 복제 과정은 임의의 코드를 실행하고 힙 데이터를 복사할 수도 있습니다.
<code>Clone</code>에 대한 더 자세한 내용은 4장의 <a href="ch04-01-what-is-ownership.html#ways-variables-and-data-interact-clone">‘변수와 데이터 간 상호작용 방식:
클론 (clone)’</a><!-- ignore -->
절을 참고하세요.</p>
<p><code>Clone</code>을 파생하면 <code>clone</code> 메서드가 구현되는데, 이는 타입 전체에 대해 구현될
때 타입의 각 부분에 대해 <code>clone</code>을 호출합니다. 이는 <code>Clone</code>을 파생하기 위해서는
타입의 모든 필드나 값 또한 <code>Clone</code>을 구현해야 한다는 것을 의미합니다.</p>
<p><code>Clone</code>이 필요한 경우의 한 예에는 슬라이스에 <code>to_vec</code> 메서드를 호출할 때가
있습니다. 슬라이스는 자신이 가진 타입 인스턴스를 소유하지 않지만, <code>to_vec</code>에서
반환된 벡터는 자신의 인스턴스를 소유해야 하므로, <code>to_vec</code>은 각 아이템에 대해
<code>clone</code>을 호출합니다. 따라서 슬라이스에 저장된 타입은 <code>Clone</code>을 구현해야 합니다.</p>
<p><code>Copy</code> 트레이트는 임의의 코드 없이 스택에 저장된 비트만 복사하여 값을
복제할 수 있게 해 줍니다. <code>Copy</code>에 대한 더 자세한 내용은 4장의
<a href="ch04-01-what-is-ownership.html#stack-only-data-copy">‘스택에만 저장되는 데이터: 복사 (copy)’</a><!-- ignore -->절을
참고하세요.</p>
<p><code>Copy</code> 트레이트에는 아무 메서드도 정의되어 있지 않은데, 이는 프로그래머가
메서드를 오버로딩하고 임의의 코드를 실행하지 않는다는 가정을 위반하는 것을
방지하기 위해서입니다. 따라서 모든 프로그래머는 복사가 매우 빠르게 수행될
것이라고 가정할 수 있습니다.</p>
<p>어떤 타입에 대해 <code>Copy</code>를 파생하려면 그 타입의 모든 부분이 <code>Copy</code>를 구현해야
합니다. <code>Copy</code>를 구현하는 타입은 또한 <code>Clone</code>을 구현해야 하는데, 왜냐하면 <code>Copy</code>를
구현하는 타입은 <code>Copy</code>와 동일한 작업을 수행하는 <code>Clone</code>의 단순한 구현체를 가지고
있기 때문입니다.</p>
<p><code>Copy</code> 트레이트는 드물게만 요구됩니다; <code>Copy</code>를 구현하는 타입은
최적화가 가능하므로 <code>clone</code>을 호출할 필요가 없으며, 이는 코드를 더
간결하게 만듭니다.</p>
<p><code>Copy</code>를 사용하여 가능한 모든 것은 <code>Clone</code>을 사용하여 수행할 수 있지만, 코드가
느려지거나 <code>clone</code>을 사용해야 하는 경우가 있을 수 있습니다.</p>
<h3 id="어떤-값을-고정-크기의-값으로-매핑하기-위한-hash"><a class="header" href="#어떤-값을-고정-크기의-값으로-매핑하기-위한-hash">어떤 값을 고정 크기의 값으로 매핑하기 위한 <code>Hash</code></a></h3>
<p><code>Hash</code> 트레이트는 해시 함수를 사용하여 임의의 크기를 가진 타입의 인스턴스를
고정 크기의 값으로 매핑할 수 있게 해 줍니다. <code>Hash</code>를 파생하면 <code>hash</code> 메서드가
구현됩니다. 파생된 <code>hash</code> 메서드의 구현체는 타입의 각 부분에 대해 <code>hash</code>를
호출한 결과를 조합하는데, 이는 <code>Hash</code>를 파생하기 위해서는 타입의 모든 필드
혹은 값 또한 <code>Hash</code>를 구현해야 한다는 것을 의미합니다.</p>
<p><code>Hash</code>를 필요로 하는 한 가지 예는 효율적으로 데이터를 저장하기 위하여
<code>HashMap&lt;K, V&gt;</code>에 키를 저장할 때입니다.</p>
<h3 id="기본값을-위한-default"><a class="header" href="#기본값을-위한-default">기본값을 위한 <code>Default</code></a></h3>
<p><code>Default</code> 트레이트는 타입에 대한 기본값을 생성할 수 있게 해 줍니다. <code>Default</code>를
파생하면 <code>default</code> 함수가 구현됩니다. 파생된 <code>default</code> 함수의 구현체는
타입의 각 부분에 대해 <code>default</code>를 호출하는데, 이는 <code>Default</code>를 파생하기
위해서는 타입의 모든 필드 혹은 값 또한 <code>Default</code>를 구현해야 한다는 것을
의미합니다.</p>
<p><code>Default::default</code> 함수는 일반적으로 5장의
<a href="ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax">‘기존 인스턴스를 이용해 새 인스턴스를 만들 때 구조체 업데이트 문법 사용하기’</a><!-- ignore -->절에서
다룬 구조체 업데이트 구문과 함께 사용됩니다.
구조체의 몇 개의 필드만 커스터마이징한 다음
나머지 필드에 대해 기본값을 설정하고 사용하려면
<code>..Default::default()</code>를 사용할 수
있습니다.</p>
<p><code>Default</code> 트레이트는 예를 들면 <code>Option&lt;T&gt;</code> 인스턴스에서 <code>unwrap_or_default</code>
메서드를 사용할 때 필요합니다. <code>Option&lt;T&gt;</code>가 <code>None</code>이면, <code>unwrap_or_default</code>
메서드는 <code>Option&lt;T&gt;</code>에 저장되는 <code>T</code> 타입에 대한 <code>Default::default</code>의 결과를
반환합니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="appendix-02-operators.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="appendix-04-useful-development-tools.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="appendix-02-operators.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="appendix-04-useful-development-tools.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    </body>
</html>
