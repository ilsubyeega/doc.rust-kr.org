<!DOCTYPE HTML>
<html lang="ko" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>데이터 타입 - Rust 프로그래밍 언어</title>


        <!-- Custom HTML head -->
        <meta name="view-transition" content="same-origin" />

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="additional.css">
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Rust Programming Language</a></li><li class="chapter-item expanded affix "><a href="foreword.html">들어가기에 앞서</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">소개</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> 시작해봅시다</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> 러스트 설치</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> 카고를 사용해봅시다</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> 추리 게임</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> 일반적인 프로그래밍 개념</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> 변수와 가변성</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html" class="active"><strong aria-hidden="true">3.2.</strong> 데이터 타입</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> 함수</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> 주석</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> 제어 흐름문</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> 소유권 이해하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> 소유권이 뭔가요?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> 참조와 대여</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> 슬라이스</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> 구조체로 연관된 데이터를 구조화하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> 구조체 정의 및 인스턴트화</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> 구조체를 사용한 예제 프로그램</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> 메서드 문법</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> 열거형과 패턴 매칭</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> 열거형 정의하기</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> match 제어 흐름 구조</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> if let을 사용한 간결한 제어 흐름</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> 커져 가는 프로젝트를 패키지, 크레이트, 모듈로 관리하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> 패키지와 크레이트</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> 모듈을 정의하여 스코프 및 공개 여부 제어하기</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> 경로를 사용하여 모듈 트리의 아이템 참조하기</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> use 키워드로 경로를 스코프 안으로 가져오기</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> 별개의 파일로 모듈 분리하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> 일반적인 컬렉션</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> 벡터에 여러 값의 목록 저장하기</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> 문자열에 UTF-8 텍스트 저장하기</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> 해시맵에 서로 연관된 키와 값 저장하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> 에러 처리</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> panic!으로 복구 불가능한 에러 처리하기</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Result로 복구 가능한 에러 처리하기</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic!이냐, panic!이 아니냐, 그것이 문제로다</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> 제네릭 타입, 트레이트, 라이프타임</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> 제네릭 데이터 타입</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> 트레이트로 공통된 동작을 정의하기</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> 라이프타임으로 참조자의 유효성 검증하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> 자동화 테스트 작성하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> 테스트 작성 방법</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> 테스트 실행 방법 제어하기</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> 테스트 조직화</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> I/O 프로젝트: 커맨드 라인 프로그램 만들기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> 커맨드 라인 인수 받기</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> 파일 읽기</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> 모듈성과 에러 처리 향상을 위한 리팩터링</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> 테스트 주도 개발로 라이브러리 기능 개발하기</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> 환경 변수 사용하기</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> 표준 출력 대신 표준 에러로 에러 메시지 작성하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> 함수형 언어의 특성: 반복자와 클로저</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> 클로저: 자신의 환경을 캡처하는 익명 함수</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> 반복자로 일련의 아이템들 처리하기</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> I/O 프로젝트 개선하기</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> 성능 비교하기: 루프 vs. 반복자</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> 카고와 Crates.io 더 알아보기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> 릴리즈 프로필을 통한 빌드 커스터마이징하기</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Crates.io에 크레이트 배포하기</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> 카고 작업공간</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> cargo install로 Crates.io에 있는 바이너리 설치하기</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> 커스텀 명령어로 카고 확장하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> 스마트 포인터</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box&lt;T&gt;를 사용하여 힙에 있는 데이터 가리키기</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Deref 트레이트로 스마트 포인터를 보통의 참조자처럼 취급하기</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Drop 트레이트로 메모리 정리 코드 실행하기</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, 참조 카운트 스마트 포인터</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt;와 내부 가변성 패턴</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> 순환 참조는 메모리 누수를 발생시킬 수 있습니다</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> 겁 없는 동시성</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> 스레드를 이용하여 코드를 동시에 실행하기</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> 메시지 패싱을 사용하여 스레드 간 데이터 전송하기</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> 공유 상태 동시성</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Sync와 Send 트레이트를 이용한 확장 가능한 동시성</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> 러스트의 객체 지향 프로그래밍 기능들</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> 객체 지향 언어의 특성</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> 트레이트 객체를 사용하여 다른 타입의 값 허용하기</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> 객체 지향 디자인 패턴 구현하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> 패턴과 매칭</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> 패턴이 사용될 수 있는 모든 곳</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> 반박 가능성: 패턴이 매칭에 실패할지의 여부</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> 패턴 문법</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> 고급 기능</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> 안전하지 않은 러스트</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> 고급 트레이트</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> 고급 타입</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> 고급 함수와 클로저</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> 매크로</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> 최종 프로젝트: 멀티스레드 웹 서버 구축하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> 싱글스레드 웹 서버 구축하기</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> 싱글스레드 서버를 멀티스레드 서버로 바꾸기</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> 우아한 종료와 정리</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> 부록</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - 키워드</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - 연산자와 기호</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - 파생 가능한 트레이트</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - 유용한 개발 도구</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - 에디션</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - 번역본</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - 러스트가 만들어지는 과정과 ‘Nightly 러스트’</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 프로그래밍 언어</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="데이터-타입"><a class="header" href="#데이터-타입">데이터 타입</a></h2>
<p>러스트의 모든 값은 특정한 <em>타입</em>을 가지며, 이는 러스트가 해당 데이터로 작업하는
방법을 알 수 있도록 어떤 종류의 데이터가 지정되고 있는지 알려줍니다. 여기서는
타입을 스칼라 타입과 복합 타입, 두 가지 부분 집합으로 나누어 보겠습니다.</p>
<p>러스트는 <em>정적 타입의 (statically typed)</em> 언어라는 점을 주지하세요.
이게 의미하는 바는 모든 변수의 타입이 컴파일 시점에 반드시 정해져 있어야 한다는 겁니다.
보통 컴파일러는 우리가 값을 어떻게 사용하는지에 따라 타입을 추측할 수 있습니다. 2장의
<a href="ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">‘비밀번호와 추릿값을 비교하기’</a><!-- ignore -->에서
<code>String</code>에 <code>parse</code>를 사용하여 숫자로 변환했던 경우처럼
여러 가지 타입이 가능한 경우에는 다음과 같이 반드시
타입 명시를 추가해야 합니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let guess: u32 = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
<span class="boring">}</span></code></pre></pre>
<p>여기에 <code>: u32</code>라는 타입 명시를 하지 않으면 러스트는 아래와 같은 에러를
출력하는데, 이는 컴파일러에게 사용하고자 하는 타입이 무엇인지에 대한
추가적인 정보가 필요하다는 뜻입니다:</p>
<pre><code class="language-console">$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0282]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let guess = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
  |         ^^^^^
  |
help: consider giving `guess` an explicit type
  |
2 |     let guess: _ = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
  |              +++

For more information about this error, try `rustc --explain E0282`.
error: could not compile `no_type_annotations` due to previous error
</code></pre>
<p>다양한 데이터 타입들의 타입 명시를 살펴보겠습니다.</p>
<h3 id="스칼라-타입"><a class="header" href="#스칼라-타입">스칼라 타입</a></h3>
<p><em>스칼라 (scalar)</em> 타입은 하나의 값을 표현합니다. 러스트는 정수, 부동 소수점 숫자, 부울린 (boolean),
그리고 문자, 이렇게 네 가지 스칼라 타입을 갖고 있습니다. 아마 다른 프로그래밍 언어에서도 이런 걸 본 적이
있을 겁니다. 러스트에서는 이들이 어떤 식으로 동작하는지 살펴보도록 합시다.</p>
<h4 id="정수형"><a class="header" href="#정수형">정수형</a></h4>
<p><em>정수형 (integer type)</em> 은 소수점이 없는 숫자입니다. 2장에서
정수형 중 하나인 <code>u32</code> 타입을 사용했었죠. 해당 타입의 선언은
부호 없는 32비트 변수임을 나타냅니다 (부호 있는 타입은 <code>u</code> 대신
<code>i</code>로 시작합니다.) 표 3-1은 러스트에서 사용되는 정수형들을
보여줍니다. 이 변형 중 어떤 것이라도 정숫값의 타입 선언에
사용할 수 있습니다.</p>
<p><span class="caption">표 3-1: 러스트의 정수형 타입들</span></p>
<div class="table-wrapper"><table><thead><tr><th>길이</th><th>부호 있음 (signed)</th><th>부호 없음 (unsigned)</th></tr></thead><tbody>
<tr><td>8-bit</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16-bit</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32-bit</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64-bit</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>128-bit</td><td><code>i128</code></td><td><code>u128</code></td></tr>
<tr><td>arch</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
</div>
<p>각각의 타입은 부호 있는 (signed) 혹은 부호 없는 (unsigned) 타입이며 명시된 크기를
갖습니다. 부호 혹은 부호 없음의 의미는, 이 타입이 음수를 다룰 수 있는지를
나타냅니다. 다르게 말하면, 숫자가 부호를 가져야 하는 경우인지 (부호 있는)
혹은 오직 양수만을 가질 것이기에 부호 없이 표현 가능한지를 (부호 없는)
나타냅니다. 종이에 숫자 기재하는 것과 같습니다:
부호와 함께 다뤄야 하는 경우 숫자는 덧셈이나 뺄셈 기호와 함께 표시하지요.
하지만 숫자가 양수라고 가정해도 문제없는 상황에는 부호 없이 표시하게 됩니다. 
부호 있는 숫자는 <a href="https://en.wikipedia.org/wiki/Two%27s_complement">2의 보수</a><!-- ignore -->형태를 사용하여
저장됩니다.</p>
<p>각 부호 있는 타입의 변수는 -(2<sup>n - 1</sup>)부터 2<sup>n - 1</sup> - 1까지의 값을
저장할 수 있습니다. 여기서 <em>n</em>은 사용되는 타입의 비트 수입니다. 따라서 <code>i8</code>은
-(2<sup>7</sup>)에서 2<sup>7</sup> - 1까지의 값, 즉 -128에서 127 사이의 값을 저장할 수
있습니다. 부호 없는 타입은 0에서 2<sup>n</sup> - 1까지의 값을 저장할 수 있습니다. 그래서
<code>u8</code> 타입은 0에서 2<sup>8</sup> - 1 다시 말해, 0에서 255까지의 값을 저장할 수 있습니다. </p>
<p>추가로, <code>isize</code>와 <code>usize</code> 타입은 여러분의 프로그램이 동작하는 컴퓨터
환경에 따라 결정되는데, 위 테이블에는 ‘arch’라고 적시되어 있습니다.
64-bit 아키텍처이면 64비트를, 32-bit 아키텍처이면 32비트를 갖게
됩니다.</p>
<p>정수형 리터럴은 표 3-2에서 보시는 것과 같은 형태로 작성할 수 있습니다.
여러 숫자 타입이 될 수 있는 숫자 리터럴에는 <code>57u8</code>과 같은 타입 접미사를
사용하여 타입을 지정할 수 있습니다. <code>1_000</code>처럼 시각적인 구분으로
읽기 쉽게 하기 위해서 <code>_</code>을 사용할 수 있는데, 이는 <code>1000</code>이라고 쓴 것과
똑같은 값이 됩니다.</p>
<p><span class="caption">표 3-2: 러스트의 정수형 리터럴</span></p>
<div class="table-wrapper"><table><thead><tr><th>숫자 리터럴</th><th>예</th></tr></thead><tbody>
<tr><td>Decimal</td><td><code>98_222</code></td></tr>
<tr><td>Hex</td><td><code>0xff</code></td></tr>
<tr><td>Octal</td><td><code>0o77</code></td></tr>
<tr><td>Binary</td><td><code>0b1111_0000</code></td></tr>
<tr><td>Byte (<code>u8</code> only)</td><td><code>b'A'</code></td></tr>
</tbody></table>
</div>
<p>그러면 어떤 타입의 정수를 사용해야 하는지는 어떻게 알아낼까요? 확실히
정해진 경우가 아니라면 러스트의 기본값인 <code>i32</code>가 일반적으로 좋은
시작 지점이 됩니다. <code>isize</code>나 <code>usize</code>는 주로 어떤 컬렉션 종류의 인덱스에
사용됩니다.</p>
<blockquote>
<h5 id="정수-오버플로우"><a class="header" href="#정수-오버플로우">정수 오버플로우</a></h5>
<p>여러분이 0과 255 사이의 값을 담을 수 있는 <code>u8</code> 타입의 변수를 갖고 있다고
해봅시다. 만약에 이 변수에 256처럼 범위 밖의 값으로 변경하려고 하면
<em>정수 오버플로우 (integer overflow)</em> 가 일어나는데, 이는 둘 중
한 가지 동작을 일으킵니다. 코드를 디버그 모드에서 컴파일하는 경우,
러스트는 런타임에 정수 오버플로우가 발생했을 때 <em>패닉 (panic)</em> 을 발생시키는
검사를 포함시킵니다. 러스트에서는 에러가 발생하면서 프로그램이 종료되는 경우
패닉이라는 용어를 사용합니다; 9장의
<a href="ch09-01-unrecoverable-errors-with-panic.html">‘<code>panic!</code>으로 복구 불가능한 에러 처리하기’</a><!-- ignore -->절에서
패닉에 대해 좀 더 자세히 다루겠습니다.</p>
<p><code>--release</code> 플래그를 사용하여 코드를 릴리즈 모드로 컴파일하는 경우에는
패닉을 발생시키는 정수 오버플로우 검사를 실행파일에 포함시키지 않습니다.
대신 오버플로우가 발생하면 러스트는 <em>2의 보수 감싸기 (two's complement wrapping)</em>
을 수행합니다. 짧게 설명하자면, 해당 타입이 가질 수 있는 최댓값보다 더 큰 값은 
허용되는 최솟값으로 ‘돌아갑니다 (wrap around)’. <code>u8</code>의 경우 256은 0이,
257은 1이 되는 식입니다. 프로그램은 패닉을 발생시키지 않으나, 해당 변수는
아마도 여러분이 예상치 못했던 값을 갖게 될 겁니다. 정수 오버플로우의
감싸기 동작에 의존하는 것은 에러로 간주됩니다.</p>
<p>명시적으로 오버플로우의 가능성을 다루기 위해서는 표준 라이브러리에서
기본 수치 타입에 대해 제공하는 아래 메서드 종류들을 사용할 수 있습니다:</p>
<ul>
<li><code>wrapping_add</code>와 같은 <code>wrapping_*</code> 메서드로 감싸기 동작 실행하기</li>
<li><code>checked_*</code> 메서드를 사용하여 오버플로우가 발생하면 <code>None</code> 값 반환하기</li>
<li><code>overflowing_*</code> 메서드를 사용하여 값과 함께 오버플로우 발생이 있었는지를
알려주는 부울린 값 반환하기</li>
<li><code>saturating_*</code> 메서드를 사용하여 값의 최대 혹은 최솟값 사이로
제한하기</li>
</ul>
</blockquote>
<h4 id="부동-소수점-타입"><a class="header" href="#부동-소수점-타입">부동 소수점 타입</a></h4>
<p>러스트에도 소수점을 갖는 숫자인 <em>부동 소수점 (floating-point) 숫자</em> 기본
타입이 두 가지 있습니다. 러스트의 부동 소수점 타입은 <code>f32</code>와 <code>f64</code>로,
각각 32bit와 64bit의 크기를 갖습니다. 기본 타입은 <code>f64</code>인데, 그 이유는
현대의 CPU 상에서 <code>f64</code>가 <code>f32</code>와 대략 비슷한 속도를 내면서도 더 정밀하기
때문입니다. 모든 부동 소수점 타입은 부호가 있습니다.</p>
<p>다음은 부동 소수점 숫자의 용례입니다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}</code></pre></pre>
<p>부동 소수점 숫자는 IEEE-754 표준을 따릅니다. <code>f32</code> 타입은 1배 수 정밀도 (single-precision) 인
부동 소수점이고, <code>f64</code>는 2배 수 정밀도 (double-precision) 입니다.</p>
<h4 id="수치-연산"><a class="header" href="#수치-연산">수치 연산</a></h4>
<p>러스트는 모든 숫자 타입에 대해서 여러분이 예상할 수 있는 기본 수학 연산 기능을
제공합니다: 더하기, 빼기, 곱하기, 나누기 등등을 말이죠. 정수 나눗셈은 가장
가까운 정숫값으로 버림을 합니다. 아래 코드는 <code>let</code> 구문 내에서 각 연산을
어떻게 사용하는지를 보여줍니다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // 덧셈
    let sum = 5 + 10;

    // 뺄셈
    let difference = 95.5 - 4.3;

    // 곱셈
    let product = 4 * 30;

    // 나눗셈
    let quotient = 56.7 / 32.2;
    let truncated = -5 / 3; // 결괏값은 -1입니다

    // 나머지 연산
    let remainder = 43 % 5;
}</code></pre></pre>
<p>위의 구문에서 각 표현식은 수학 연산자를 사용하여 값을 평가한
뒤, 그 값을 변수에 묶어 넣습니다. <a href="appendix-02-operators.html">부록 B</a><!-- ignore -->에
러스트가 제공하는 모든 연산자 목록이
있습니다.</p>
<h4 id="부울린-타입"><a class="header" href="#부울린-타입">부울린 타입</a></h4>
<p>대부분의 다른 언어들처럼, 러스트에서의 부울린 (boolean) 타입도 <code>true</code>와 <code>false</code> 두
값을 가질 수 있습니다. 부울린 값은 1바이트 크기입니다. 러스트에서 부울린 타입은
<code>bool</code>로 명시됩니다. 예를 들면:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let t = true;

    let f: bool = false; // 명시적인 타입 어노테이션
}</code></pre></pre>
<p>부울린 값을 사용하는 주요 방식은 <code>if</code> 표현식과 같은 조건문에서 사용하는
것입니다. 러스트에서 <code>if</code> 표현식이 동작하는 방식에 대해서는
<a href="ch03-05-control-flow.html#control-flow">‘제어 흐름문’</a><!-- ignore -->절에서 다루겠습니다.</p>
<h4 id="문자-타입"><a class="header" href="#문자-타입">문자 타입</a></h4>
<p>러스트의 <code>char</code>는 이 언어의 가장 기본적인 알파벳 타입입니다.
다음 코드는 <code>char</code> 값을 선언하는 몇 가지 예시입니다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let c = 'z';
    let z: char = 'ℤ'; // 명시적인 타입 어노테이션
    let heart_eyed_cat = '😻';
}</code></pre></pre>
<p>문자열 리터럴이 큰따옴표를 쓰는 반면, <code>char</code> 타입은 작은따옴표를
쓰는 점을 주목하세요. 러스트의 <code>char</code> 타입은 4바이트 크기이며 유니코드
스칼라 값을 표현하며, 이는 ASCII보다 훨씬 더 많은 값을 표현할 수
있다는 의미입니다. 억양 표시가 있는 문자, 한국어/중국어/일본어 문자,
이모지, 넓이가 0인 공백문자 모두가 러스트에서는 유효한 <code>char</code> 값입니다.
유니코드 스칼라 값의 범위는 <code>U+0000</code>에서 <code>U+D7FF</code>, 그리고 <code>U+E000</code>에서
<code>U+10FFFF</code>입니다. 하지만 ‘문자’는 유니코드를 위한 개념이 아니기 때문에,
‘문자’에 대한 여러분의 직관은 <code>char</code>와 들어맞지 않을지도 모릅니다. 8장의
<a href="ch08-02-strings.html#storing-utf-8-encoded-text-with-strings">‘문자열에 UTF-8 텍스트 저장하기’</a><!-- ignore -->
에서 이 주제에 대해 자세히 다루겠습니다.</p>
<h3 id="복합-타입"><a class="header" href="#복합-타입">복합 타입</a></h3>
<p><em>복합 타입 (compound type)</em> 은 여러 값을 하나의 타입으로 묶을 수 있습니다.
러스트에는 튜플 (tuple) 과 배열 (array), 두 가지 기본 복합 타입이 있습니다.</p>
<h4 id="튜플-타입"><a class="header" href="#튜플-타입">튜플 타입</a></h4>
<p><em>튜플</em>은 다양한 타입의 여러 값을 묶어 하나의 복합 타입으로 만드는 일반적인
방법입니다. 튜플은 고정된 길이를 갖습니다. 즉, 한번 선언되면 그 크기를
늘리거나 줄일 수 없습니다.</p>
<p>괄호 안에 쉼표로 구분하여 값들의 목록을 작성하면 튜플을
만들 수 있습니다. 튜플 내의 각 위치는 타입을 갖고,
이 튜플 내의 타입들은 서로 달라도 됩니다. 다음은 (안 써도 괜찮지만)
타입을 명시해 본 예제입니다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}</code></pre></pre>
<p>튜플은 하나의 복합 요소로 취급되므로 변수 <code>tup</code>은 튜플 전체가 바인딩됩니다.
튜플로부터 개별 값을 얻어오려면 아래와 같이 패턴 매칭을 하여 튜플 값을
해체하면 사용하면 됩니다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!(&quot;The value of y is: {y}&quot;);
}</code></pre></pre>
<p>이 프로그램은 먼저 튜플을 만든 후 이를 변수 <code>tup</code>에 바인딩시킵니다.
그다음 <code>let</code>을 이용하는 패턴을 사용하여 <code>tup</code>을 세 개의 분리된 변수 <code>x</code>, <code>y</code>,
그리고 <code>z</code>로 바꿉니다. 이것을 <em>구조 해체 (destructuring)</em> 라고 부르는 이유는
하나의 튜플을 세 부분으로 나누기 때문입니다. 최종적으로 프로그램은 <code>y</code>의 값을
출력할 것이고 이는 <code>6.4</code>입니다.</p>
<p>마침표(<code>.</code>) 뒤에 접근하고자 하는 값의 인덱스를 쓰는 방식으로도 튜플 요소에
접근할 수 있습니다. 예를 들면:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}</code></pre></pre>
<p>위의 프로그램은 튜플 <code>x</code>를 만들고, 인덱스를 사용하여 이 튜플의
각 요소에 접근합니다. 대부분의 언어가 그렇듯이 튜플의 첫 번째
인덱스는 0입니다. </p>
<p>아무 값도 없는 튜플은 <em>유닛 (unit)</em> 이라는 특별한 이름을 갖습니다.
이 값과 타입은 모두 <code>()</code>로 작성되고 빈 값이나 비어있는 반환 타입을
나타냅니다. 표현식이 어떠한 값도 반환하지 않는다면 암묵적으로 유닛
값을 반환하게 됩니다.</p>
<h4 id="배열-타입"><a class="header" href="#배열-타입">배열 타입</a></h4>
<p>여러 값의 집합체를 만드는 다른 방법으로는 <em>배열</em>이 있습니다. 튜플과는 달리
배열의 모든 요소는 모두 같은 타입이여야 합니다. 몇몇 다른 언어들과는 달리
러스트의 배열은 고정된 길이를 갖습니다.</p>
<p>대괄호 안에 쉼표로 구분한 값들 나열해서 배열을
만들 수 있습니다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];
}</code></pre></pre>
<p>여러분이 힙보다는 스택에 데이터를 할당하고 싶을 때나
(힙과 스택은 <a href="ch04-01-what-is-ownership.html#the-stack-and-the-heap">4장</a><!-- ignore -->에서
더 다루겠습니다) 항상 고정된 개수의 요소로 이루어진 경우라면
배열이 유용합니다. 하지만 배열은 벡터 타입처럼 유연하지는 않습니다.
벡터는 표준 라이브러리가 제공하는 배열과 유사한 컬렉션 타입인데
크기를 늘리거나 줄일 수 있습니다. 배열을 이용할지 혹은
벡터를 이용할지 잘 모르겠다면, 아마도 벡터를 사용해야 할 겁니다.
<a href="ch08-01-vectors.html">8장</a><!-- ignore -->에서 벡터에 대해 더 자세히 다룰 예정입니다.</p>
<p>그러나 요소의 개수가 바뀔 필요가 없다는 것을 알고 있을 때라면 배열이
더 유용합니다. 한 가지 예로, 프로그램에서 달의 이름을 이용하려고 한다면,
이것이 언제나 12개의 요소만 가지고 있을 것이라는 사실을 알고 있으므로,
아마도 벡터보다는 배열을 사용할 것입니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let months = [&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;,
              &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;];
<span class="boring">}</span></code></pre></pre>
<p>다음과 같이 대괄호 안에 요소의 타입을 쓰고 세미콜론을 쓴 뒤 요소의
개수를 적는 식으로 배열의 타입을 작성할 수도 있습니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: [i32; 5] = [1, 2, 3, 4, 5];
<span class="boring">}</span></code></pre></pre>
<p>여기서 <code>i32</code>는 각 요소의 타입입니다. 세미콜론 뒤의 숫자 <code>5</code>는
배열이 5개의 요소를 갖고 있음을 나타냅니다.</p>
<p>또한 다음과 같이 대괄호 안에 초깃값과 세미콜론을 쓴 다음 배열의 길이를
적는 방식을 사용하여 모든 요소가 동일한 값으로 채워진 배열을 초기화할 수도
있습니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [3; 5];
<span class="boring">}</span></code></pre></pre>
<p><code>a</code>라는 이름의 배열은 모두 <code>3</code>으로 채워진 <code>5</code>개의 요소를 갖게 될
것입니다. 이는 <code>let a = [3, 3, 3, 3, 3];</code>이라고 쓴 것과 똑같지만
좀더 편리한 방식입니다.</p>
<h5 id="배열-요소에-접근하기"><a class="header" href="#배열-요소에-접근하기">배열 요소에 접근하기</a></h5>
<p>배열은 스택에 할당될 수 있는 계산 가능한 고정된 크기의 단일 메모리
뭉치입니다. 아래와 같이 인덱스를 통해 배열 요소에 접근할 수
있습니다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}</code></pre></pre>
<p>이 예제에서 <code>first</code>로 명명된 변수는 배열에서 인덱스 <code>[0]</code>의 값이므로
<code>1</code>이 될 것입니다. <code>second</code>로 명명된 변수는 배열의 <code>[1]</code> 인덱스로부터
얻어진 값 <code>2</code>가 되겠죠.</p>
<h5 id="유효하지-않은-배열-요소에-대한-접근"><a class="header" href="#유효하지-않은-배열-요소에-대한-접근">유효하지 않은 배열 요소에 대한 접근</a></h5>
<p>만약 배열의 끝을 넘어선 요소에 접근하려고 하면 어떤 일이 벌어지는지
알아봅시다. 사용자로부터 배열 인덱스를 입력받기 위해서 2장의 추리
게임과 유사한 아래 코드를 실행한다 칩시다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><code class="language-rust ignore panics">use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!(&quot;Please enter an array index.&quot;);

    let mut index = String::new();

    io::stdin()
        .read_line(&amp;mut index)
        .expect(&quot;Failed to read line&quot;);

    let index: usize = index
        .trim()
        .parse()
        .expect(&quot;Index entered was not a number&quot;);

    let element = a[index];

    println!(&quot;The value of the element at index {index} is: {element}&quot;);
}</code></pre>
<p>이 코드는 성공적으로 컴파일됩니다. <code>cargo run</code>으로 코드를 실행한 뒤
<code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, 혹은 <code>4</code>를 입력한다면 프로그램은 그 인덱스에 해당하는
배열 값을 출력할 것입니다. 그 대신에 이 배열의 끝을 넘어서는 <code>10</code> 같은
숫자를 입력하면, 아래와 같은 출력을 보게 될 것입니다:</p>
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-15-invalid-array-access
cargo run
10
-->
<pre><code class="language-console">thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:19:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>프로그램은 인덱스 연산에서 잘못된 값을 사용한 시점에서 <em>런타임</em> 에러를
발생시켰습니다. 이 프로그램은 에러 메시지와 함께 종료되고 마지막 <code>println!</code> 구문을
실행하지 못했습니다. 인덱스를 이용하여 요소에 접근을 시도하는 경우,
러스트는 여러분이 명시한 인덱스가 배열 길이보다 작은지 검사할 것입니다.
인덱스가 배열 길이보다 크거나 같을 경우 러스트는 패닉 (panic) 을 일으킵니다.
특히 위의 경우 이러한 검사는 런타임에서 일어나야 하는데, 이는 사용자가
코드를 실행한 뒤에 어떤 값을 입력할지 컴파일러로서는 알 수 없기
때문입니다.</p>
<p>이 예제는 러스트의 안전성 원칙이 동작하는 하나의 예입니다. 많은 저수준 언어들에서는
이러한 검사가 이루어지지 않고, 여러분이 잘못된 인덱스를 제공하면 유효하지 않은
메모리에 접근이 가능합니다. 러스트는 이런 메모리 접근을 허용하고 계속 실행하는
대신 즉시 실행을 종료함으로써 이런 종류의 에러로부터 여러분을 보호합니다. 러스트의
에러 처리 및 패닉을 일으키지 않으면서 유효하지 않은 메모리 접근도 허용하지 않는
읽기 쉽고 안전한 코드를 작성하는 방법에 대해서는 9장에서 더 자세히 다루겠습니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch03-01-variables-and-mutability.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch03-03-how-functions-work.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch03-01-variables-and-mutability.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch03-03-how-functions-work.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    </body>
</html>
